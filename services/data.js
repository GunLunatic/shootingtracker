// Generated by CoffeeScript 1.10.0
var Converter, Data, Shooting, callbacks, ld, moment, mongoose, node, nodefn, redis, redisTTL, request, w,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

w = require('when');

node = require('when/node');

callbacks = require('when/callbacks');

mongoose = require('mongoose');

Shooting = require('.././data/schema/shooting');

redis = require('redis');

moment = require('moment');

redisTTL = 1 * 60 * 60;

nodefn = require('when/node');

request = require('request');

Converter = require('csvtojson').Converter;

ld = require('lodash');

Data = (function() {
  function Data(config, logger1) {
    var ref1, userpass;
    this.logger = logger1;
    this.pullSheetData = bind(this.pullSheetData, this);
    this.updateFromCSV = bind(this.updateFromCSV, this);
    this.getTotals = bind(this.getTotals, this);
    this.getByYear = bind(this.getByYear, this);
    this.getRedisKeys = bind(this.getRedisKeys, this);
    this.deleteRedisKey = bind(this.deleteRedisKey, this);
    this.getMongoConn = bind(this.getMongoConn, this);
    this.getRedisConn = bind(this.getRedisConn, this);
    if (config == null) {
      throw 'config is required!';
    }
    this.googleSheetURL = config['google-docs'].url;
    this.redisPort = config.redis.port;
    userpass = '';
    if (config.mongo.user != null) {
      if (config.mongo.password == null) {
        throw 'no password, password is required if user is set';
      }
      userpass = config.mongo.user + ":" + config.mongo.password + "@";
    }
    this.mongoURL = "mongodb://" + userpass + config.mongo.url;
    if (this.logger == null) {
      this.logger = (require('bunyan'))({
        name: 'mst-data',
        level: (((ref1 = config.logging) != null ? ref1.level : void 0) != null) || 10
      });
    }
  }

  Data.prototype.getRedisConn = function() {
    var promise;
    promise = w.promise((function(_this) {
      return function(resolve, reject) {
        var redisClient;
        if (_this.redisClient != null) {
          return resolve(_this.redisClient);
        } else {
          redisClient = redis.createClient(_this.redisPort);
          redisClient.on('connect', function() {
            _this.redisClient = redisClient;
            return resolve(redisClient);
          });
          return redisClient.on('error', function(err) {
            _this.logger.error('Redis error ' + err);
            return reject(err);
          });
        }
      };
    })(this));
    return promise;
  };

  Data.prototype.getMongoConn = function() {
    var logger, promise;
    mongoose.connect(this.mongoURL);
    logger = this.logger;
    promise = w.promise((function(_this) {
      return function(resolve, reject) {
        var db;
        if (_this.mongoConn != null) {
          return resolve(_this.mongoConn);
        } else {
          db = mongoose.connection;
          db.on('error', function() {
            return reject(arguments);
          });
          return db.once('open', function() {
            logger.trace('connected to mongo; proceeding');
            _this.mongoConn = mongoose.connection;
            return resolve(mongoose.connection);
          });
        }
      };
    })(this));
    return promise;
  };

  Data.prototype.deleteRedisKey = function(key) {
    var getConn, promise;
    getConn = this.getRedisConn;
    this.logger.debug("deleting redis key " + key);
    promise = w.promise(function(resolve, reject) {
      return getConn()["catch"](function(err) {
        return reject(err);
      }).then(function(redisClient) {
        return redisClient.del(key, function(err) {
          if (err != null) {
            return reject(err);
          } else {
            return resolve(true);
          }
        });
      });
    });
    return promise;
  };

  Data.prototype.getRedisKeys = function() {
    var promise;
    promise = w.promise((function(_this) {
      return function(resolve, reject) {
        _this.logger.debug("getting all redis keys");
        return _this.getRedisConn().then(function(redisClient) {
          return redisClient.keys('*', function(err, keys) {
            if (err != null) {
              reject(err);
            }
            return resolve(keys);
          });
        });
      };
    })(this));
    return promise;
  };

  Data.prototype.getByYear = function(year) {
    var getMongoConn, logger, promise, redisURL;
    this.logger.trace("getting by year for " + year);
    logger = this.logger;
    redisURL = this.redisURL;
    getMongoConn = this.getMongoConn;
    promise = w.promise((function(_this) {
      return function(resolve, reject) {
        logger.trace('connecting to redis');
        return _this.getRedisConn()["catch"](function(err) {
          return reject(err);
        }).then(function(redisClient) {
          return redisClient.get(year, function(err, reply) {
            if (err != null) {
              logger.error(err);
              return reject(err);
            } else {
              reply = JSON.parse(reply);
              if ((reply != null) && (reply.length != null) && reply.length > 0) {

                /* found in redis, return that */
                logger.debug('found in redis, returning');
                return resolve(reply);
              } else {

                /* redis returned an empty set, get from mongo */
                return getMongoConn()["catch"](function(err) {
                  return reject(err);
                }).then(function(dbconn) {
                  var begin, end;
                  logger.trace("pulling by year from mongo");
                  begin = moment(year + " Jan 01", 'YYYY mmm DD');
                  end = moment((+year + 1) + " Jan 01", 'YYYY mmm DD');
                  return Shooting.find({
                    date: {
                      $gte: begin,
                      $lt: end
                    }
                  }).exec(function(err, shootings) {
                    if (err != null) {
                      return reject(err);
                    } else {

                      /* store in redis with a one day TTL */
                      redisClient.set(year, JSON.stringify(shootings));
                      redisClient.expire(year, redisTTL);
                      return resolve(shootings);
                    }
                  });
                });
              }
            }
          });
        });
      };
    })(this));
    return promise;
  };


  /*
    return value:
    { '2014': 24, '2015': 279, totalAllYears: 303, daysSince: 2 }
   */

  Data.prototype.getTotals = function() {
    var promise;
    promise = w.promise((function(_this) {
      return function(resolve, reject) {
        var getMongoConn, key, logger, startYear, years;
        logger = _this.logger;
        logger.debug('connecting to redis');
        years = new moment();
        key = 'totals';
        startYear = 2014;
        getMongoConn = _this.getMongoConn;
        return _this.getRedisConn()["catch"](function(err) {
          return reject(err);
        }).then(function(redisClient) {
          return redisClient.get(key, function(err, reply) {
            var replyAsObj;
            if (err != null) {
              logger.error(err);
              return reject(err);
            } else {
              if ((reply != null) && (reply !== "[]")) {

                /* found in redis, return that */
                replyAsObj = JSON.parse(reply);
                logger.debug('totals found in redis, returning');
                return resolve(replyAsObj);
              } else {
                logger.debug("didn't find totals in redis; pulling fresh");

                /* redis returned an empty set, get from mongo */
                return getMongoConn()["catch"](function(err) {
                  return reject(err);
                }).then(function(dbconn) {
                  var result;
                  result = {};
                  return Shooting.count().exec(function(err, count) {
                    var now;
                    if (err != null) {
                      reject(err);
                      return;
                    }
                    result.totalAllYears = count;
                    now = new moment();
                    return Shooting.find(null, null, {
                      limit: 1
                    }).sort('-date').exec(function(err, docs) {
                      var currentYear, duration, j, lastDate, ref1, ref2, results, year;
                      if (err != null) {
                        reject(err);
                        return;
                      }
                      lastDate = docs[0].date;
                      duration = Math.floor(Math.abs(moment.duration(now.diff(lastDate)).asDays()));
                      result.daysSince = duration;
                      currentYear = new Date().getFullYear();
                      results = [];
                      for (year = j = ref1 = startYear, ref2 = currentYear; ref1 <= ref2 ? j <= ref2 : j >= ref2; year = ref1 <= ref2 ? ++j : --j) {
                        results.push((function(year) {
                          return Shooting.count({
                            date: {
                              $gte: new Date(year, 1, 1),
                              $lte: new Date(year, 12, 31)
                            }
                          }).exec(function(err, count) {
                            if (err != null) {
                              reject(err);
                            } else {
                              result[year] = count;
                              if (year === currentYear) {
                                redisClient.set(key, JSON.stringify(result));
                                redisClient.expire(key, redisTTL);
                                return resolve(result);
                              }
                            }
                          });
                        })(year));
                      }
                      return results;
                    });
                  });
                });
              }
            }
          });
        });
      };
    })(this));
    return promise;
  };

  Data.prototype.updateFromCSV = function(data) {
    var logger, promise;
    logger = this.logger;
    logger.trace("starting update from csv");
    if (data.shootings == null) {
      throw "no shootings element found in CSV data";
    }
    mongoose.connect(this.mongoURL);
    promise = w.promise(function(resolve, reject) {
      var db;
      db = mongoose.connection;
      db.on('error', function() {
        return reject(arguments);
      });
      return db.once('open', function(callback) {
        var checked, d, entry, i, len, n, ref, results, total, upsert;
        logger.debug('connected to mongo; pushing new values into db');
        d = void 0;
        i = void 0;
        len = void 0;
        ref = data.shootings;
        total = data.shootings.length;
        checked = 0;
        n = 0;
        i = 0;
        len = ref.length;
        results = [];
        while (i < len) {
          d = ref[i];
          entry = new Shooting;
          entry.date = new Date(d.date);
          entry.perpetrators = [
            {
              name: d.name
            }
          ];
          entry.killed = d.killed;
          entry.city = d.city;
          entry.wounded = d.wounded;
          entry.city = d.location.split(',')[0];
          entry.state = d.location.split(',')[1].trim();
          entry.sources = d.sources;

          /*
           find any entries on this data with the same city and state and at least one matching source
           if found, delete and re-create
           else just save each one
           */
          upsert = function(entry) {
            return Shooting.find({
              city: entry.city,
              state: entry.state,
              date: entry.date,
              sources: {
                $in: entry.sources
              }
            }).exec(function(err, shooting) {
              if (err) {
                reject(err);
              } else if (shooting.length > 1) {
                logger.fatal('found multiple entries! (this should be very rare at best)');
                logger.fatal({
                  entry: shooting
                });
              } else if (shooting.length > 0) {
                Shooting.remove({
                  _id: shooting[0]._id
                }, function(err, result) {
                  entry.save();
                });
              } else {
                ++n;
                entry.save();
              }
              ++checked;
              if (checked === total) {
                logger.warn('done writing data to Mongo (' + n + ' new records)');
                return resolve(n);
              }
            });
          };
          upsert(entry);
          results.push(i++);
        }
        return results;
      });
    });
    return promise;
  };

  Data.prototype.getSheet = function(url) {
    if (!this.googleSheetURL) {
      throw 'no google docs url found in config, should be at config["google-docs"].url';
    }
    return nodefn.lift(request)({
      uri: this.googleSheetURL
    }).then(function(result) {
      return w.resolve(result[0].body);
    });
  };

  Data.prototype.csvToJSON = function(csvStr) {
    var converter, promise;
    converter = new Converter({});
    promise = w.promise(function(resolve, reject) {
      return converter.fromString(csvStr, function(err, result) {
        if (err) {
          reject(err);
        }
        return resolve(result);
      });
    });
    return promise;
  };

  Data.prototype.pullSheetData = function() {
    var promise;
    return promise = w.promise((function(_this) {
      return function(resolve, reject) {
        return _this.getSheet().then(function(sheetStr) {
          return _this.csvToJSON(sheetStr);
        })["catch"](function(err) {
          return reject(err);
        }).then(function(result) {
          return resolve(result);
        });
      };
    })(this));
  };

  return Data;

})();

module.exports.Data = Data;
